typedef unsigned int uint;
typedef unsigned char byte;

//Кольцевой аллокатор памяти. Базовая реализация (правой половины кольца [а другой половины я и невижу [я вижу только один вариант действий при достижении предела памяти - продолжать идти по кругу пожирая хвост, закоррапчивая там память, то есть, получается, "кто (который блок) неуспел освободиться, тот сам виноват :)(:"] - я могу только про правую рассказать]). Right Ring AllocaTOR.
//(Принцип работы описан в комментариях. [Но, вообще, тут всё очень просто, как в тетрисе.])

//typedef unsigned int uint;
//typedef unsigned char byte;
extern byte *_cur;//cur[rent/sor] курсор (правая грань [плавающей] опорной точки [точки отсчёта, крутящейся на кольце])

	//Выделяется блок памяти посредством простого инкремента указателя cur[rent|sor].

byte *alloc(uint block_size)
{
	*(uint*)_cur = block_size;//в качестве заголовка достаточно [знать/иметь] только размер [выделенного] блока [памяти]
	_cur += sizeof(uint);
	{byte *ret_block_ptr = _cur;
	_cur += block_size;
	return ret_block_ptr;}
}

void **_free_list_first_ptr = 0X0;

	//А при освобождении памяти уже получается тетрис:

void free(void/*[byte]*/ *block_ptr)
{
#define BLOCK_SIZE(block_ptr) \
                      ((uint*)block_ptr)[-1]
	uint block_size = ((uint*)block_ptr)[-1];//Извлекаем[/получаем/вытаскиваем] размер [выделенного] блока [памяти]

	if ((byte*)block_ptr + block_size == _cur) //[Если] это самая удачная ситуация [счастливый случай] — удаляется последний аллоцированный блок;
		_cur -= block_size;//[тогда] в этом (счастливом) случае просто сдвигаем указатель назад на размер блока [[и производим сборку мусора справа]]

//{ПРИМЕР:
//              [Делаем:]
//‘+1 +2 +3 +4’ {символ '+' обозначает выделение, '-' освобождение, а цифра - условный/порядковый номер выделенного блока [памяти]}
//              [В памяти теперь стало:]
//Г————————————
//|+1 +2 +3 +4
//L————————————
//              [Делаем:]
//         ‘-4’
//              [В памяти теперь стало:]
//Г————————————
//|+1 +2 +3
//L————————————
//              [Делаем:]
//   ‘-2’
//    ...
//  ..[?].. {пока непонятно, что делать в этом[/таком] случае}
//}
	else {
		//В противном случае, добавляем блок во free_list, который будет использоваться[/работать] не по общепринятому (в данный момент времени)
		//принципу работы/использования списков свободных блоков, а по принципу тетриса[/домино[?]].
		*(void**)block_ptr = _free_list_first_ptr;
		*_free_list_first_ptr = block_ptr;
		return;
	}

//              [В памяти теперь стало:]
//————————————¬
//         -2 |
//————————————Ј
//              [Делаем:]
//         ‘+5’
//              [В памяти теперь стало:]
//Г————————————
//|+1 +2 +3 +5
//L————————————
//————————————¬
//         -2 |
//————————————Ј
//              [Делаем:]
//         ‘-3’ {обратите внимание на "неправильный" порядок освобождения - если здесь было бы ‘-5’, то освободить блок можно было бы сразу же [и без процедуры сборки мусора], а так приходится запоминать этот блок в списке free_list}
//              [В памяти теперь стало:]
//Г————————————
//|+1 +2 +3 +5
//L————————————
//————————————¬
//      -3 -2 |
//————————————Ј
//              [Делаем:]
//         ‘-5’
//              [В памяти теперь стало:]
//Г————————————
//|+1 +2 +3
//L————————————
//————————————¬
//      -3 -2 |
//————————————Ј

	//Выполняем[/запускаем] сборку мусора справа (быструю сборку мусора):
	//для этого просто идём по списку свободных блоков (free_list) [можете проверить самостоятельно, что после ‘-3’ (но перед ‘-5’) этот цикл сработает вхолостую]
	while (_free_list_first_ptr)
	{
//              [Как [[бы]] будто [бы] делаем:]
//         ‘-3’
//              [В памяти теперь стало:]
//Г————————————
//|+1 +2
//L————————————
//————————————¬
//         -2 |
//————————————Ј
//              [И ещё [один] раз [на следующей итерации цикла]:]
//Г————————————
//|+1
//L————————————
//————————————¬
//            |
//————————————Ј
		if ((byte*)*_free_list_first_ptr + BLOCK_SIZE(*_free_list_first_ptr) == _cur) {//и в случае совпадения (то есть мы как бы пытаемся [рекурсивно] выполнить free() [и продолжаем до тех пор, пока это неприведёт к необходимости [повторного/зацикленного] добавления во free_list])
			_cur -= BLOCK_SIZE(*_free_list_first_ptr);//выполняем действия аналогичные тем что в начале этой функции (в случае если удаляется последний аллоцированный блок)
			_free_list_first_ptr = (void**)*_free_list_first_ptr;//[освобождаем] блок свободен!
			continue;
		}
		else
			break;
	}
	//Вот и всё. (::)
}
